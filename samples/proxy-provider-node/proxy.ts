// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { Request, Response } from 'express';
import { IncomingHttpHeaders } from 'http';
import fetch, { Headers } from 'node-fetch';

import getAccessTokenOnBehalfOf from './auth';

/**
 * Returns an Authorization header value for Microsoft Graph
 * depending on the configured auth mode.
 * If in pass-through mode, the incoming header is already a
 * Microsoft Graph token, so just return it
 * If in on-behalf-of mode, the incoming header contains a
 * token that needs to be exchange for a Graph token using
 * on-behalf-of flow
 * @param {string} incomingAuthHeader - The incoming auth header ('Bearer token')
 * @returns {Promise<string>}
 */
async function processIncomingToken(incomingAuthHeader: string): Promise<string> {
  // If in pass-through mode, just return the original
  if (process.env.AUTH_PASS_THROUGH === 'true') {
    return incomingAuthHeader;
  }

  // In OBO mode, exchange the token for a Graph token
  const graphToken = await getAccessTokenOnBehalfOf(incomingAuthHeader);
  return graphToken || '';
}

/**
 * Returns a collection of headers for Microsoft Graph
 * generated by copying select headers from the incoming request
 * @param {IncomingHttpHeaders} incomingHeaders - The headers sent to the proxy
 * @returns {Promise<Headers>}
 */
async function copyRequiredHeaders(incomingHeaders: IncomingHttpHeaders): Promise<Headers> {
  const graphHeaders = new Headers();

  // Preserve the Accept header
  if (incomingHeaders['accept']) {
    console.log(`Accept: ${incomingHeaders['accept']}`);
    graphHeaders.append('accept', incomingHeaders['accept']);
  }

  // Preserve If-Match
  if (incomingHeaders['if-match']) {
    console.log(`If-Match: ${incomingHeaders['if-match']}`);
    graphHeaders.append('if-match', incomingHeaders['if-match']);
  }

  // Preserve Content-Type
  if (incomingHeaders['content-type']) {
    console.log(`Content-Type: ${incomingHeaders['content-type']}`);
    graphHeaders.append('content-type', incomingHeaders['content-type']);
  }

  // Generate the Authorization header
  if (incomingHeaders['authorization']) {
    const graphAuthHeader = await processIncomingToken(incomingHeaders['authorization']);
    graphHeaders.append('authorization', graphAuthHeader);
  }

  return graphHeaders;
}

/**
 * Proxies the request to the Microsoft Graph
 * @param {Request} req - The incoming request
 * @param {Response} res - The outgoing response
 * @returns {Promise<void>}
 */
export default async function proxyRequest(req: Request, res: Response): Promise<void> {
  console.log(`${req.method} ${req.url}`);

  // Keep required headers from incoming request
  const headers = await copyRequiredHeaders(req.headers);

  // Replace 'https://proxyhost/apiproxy' with the Microsoft
  // Graph endpoint.
  const graphUrl = `${process.env.GRAPH_HOST}${req.url}`;

  // Send the request to the Microsoft Graph endpoint
  const graphResponse = await fetch(
    graphUrl,
    {
      method: req.method,
      headers: headers,
      body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
    }
  );

  // Send back the right content type in the response
  const responseType = graphResponse.headers.get('content-type') ?? 'application/json';

  // Get the body of the Graph response
  const bodyData = await graphResponse.buffer();

  // Send the response (status, content type, body) to the
  // calling client
  res.status(graphResponse.status)
    .type(responseType)
    // Copy the request-id and client-request-id headers
    .set({
      'request-id': graphResponse.headers.get('request-id'),
      'client-request-id': graphResponse.headers.get('client-request-id')
    })
    .send(bodyData);
}
